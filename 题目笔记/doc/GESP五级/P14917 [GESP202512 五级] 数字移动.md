# P14917 [GESP202512 五级] 数字移动

## 题目描述

小 A 有一个包含 $N$ 个正整数的序列 $A=\{A_1,A_2,\cdots,A_N\}$，序列 $A$ 恰好包含 $\frac{N}{2}$ 对不同的正整数。形式化地，对于任意 $1 \le i \le N$，存在唯一一个 $j$ 满足 $1\le j \le N, i\neq j, A_i=A_j$。

小 A 希望每对相同的数字在序列中相邻，为了实现这一目的，小 A 每次操作会选择任意 $i(1\le i\le N)$，将当前序列的第 $i$ 个数字移动到任意位置，并花费对应数字的体力。

例如，假设序列 $A=\{1,2,1,3,2,3\}$，小 A 可以选择 $i=2$，将 $A_2=2$ 移动到 $A_3=1$ 的后面，此时序列变为 $\{1,1,2,3,2,3\}$，耗费 $2$ 点体力。小 A 也可以选择 $i=3$，将 $A_3=1$ 移动到 $A_2=2$ 的前面，此时序列变为 $\{1,1,2,3,2,3\}$，花费 $1$ 点体力。

小 A 可以执行任意次操作，但他希望自己每次花费的体力尽可能小。小 A 希望你能帮他计算出一个最小的 $x$，使得他能够在每次花费的体力均不超过 $x$ 的情况下令每对相同的数字在序列中相邻。

## 输入格式

第一行一个正整数 $N$，代表序列长度，保证 $N$ 为偶数。

第二行包含 $N$ 个正整数 $A_1,A_2,\ldots,A_N$，代表序列 $A$。且对于任意 $1\le i\le N$，存在唯一一个 $j$ 满足 $1\le j\le N,i\neq j,A_i=A_j$。

数据保证小 A 至少需要执行一次操作。

## 输出格式

输出一行，代表满足要求的 $x$ 的最小值。

## 输入输出样例 #1

### 输入 #1

```
6
1 2 1 3 2 3
```

### 输出 #1

```
2
```

## 说明/提示

对于 $40\%$ 的测试点，保证 $1\le N,A_i\le 100$。

对于所有测试点，保证 $1\le N,A_i\le 10^5$。

## 题解
同作为十二月的两道题，这题显然是简单的那道。不过对于很多同学来讲还有有点困难。笔者认为这题有点考察学生对题目的理解以及对规则的合理利用了。我们尝试先翻译该题。

### 题目理解
实际上就是给出一个数组，保证数组中出现的数有仅有两个。比如数组中不可能只有有一个3，要么不存在3，要么只有两个3。

这边规定移动代价为当前操作元素的大小，移动为控制当前元素到任意位置。例如移动3这个元素，我需要的代价就是3。

最终输出一个最小代价。这边的最小代价详细的说是再这个代价以内（包括）以任意代价操作任意次数。最终需要相同的元素靠在一起。

举个例子，这边有这样的数据：
```
1 2 5 5 2 1
```
那么最终输出2，第一次操作可以让最右侧的1放置到最左侧得到：
```
1 1 2 5 5 2
```
第二次操作2得到：
```
1 1 2 2 5 5
```
于是最终输出2

### 注意点
- 操作可以执行任意多的次数。这意味着，当我们控制一个元素时，我们一定可以做到将这个元素与另一半进行配对，而完全不影响后续的代价。举个例子：我们将两个中间的元素都移动到最左侧或者最右侧，这样的做法完全不会影响全局的最优解。

- 整体呈现单调性，比如最终结果是5（这边先将数据看为连续）那么<5的数据一定不满足，而>5的数据一定满足。

### 算法的设计
- 根据注意点2，我们可以很自然想到二分。当然如果你注意不到第二点，也许会先想到枚举。然后从枚举再深入一步考虑是否有单调性，想到二分。

- 根据注意点1，我们能很容易想出check函数的设计。检查当前值（x）是否满足，只需要无脑的将数组中<=x的元素给删除。然后再遍历一遍数组判断是否有相邻不等。

### 代码
注意这边的数据不一定是连续的。所以我们二分中枚举的量表示的是数组的第x大元素。这边设计从1开始，即二分1-n，但实际传入的check检查值为vec[x]。这边vec是sort过的从小到大的数组。

当然这边也可以无脑的从min-max进行二分，也可以得到正确结果。因为即使该元素不存在于数组中仍然可以进行判断。然后最优解一定会落在数组中某个元素值上。

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> a;
int n;
bool check(int x)
{
    int las=-1;
    for(int i=1;i<=n;i++)
    {
        if(a[i]<=x) continue;
        else if(a[i]==las) las=-1;
        else 
        {
            if(las==-1) las=a[i];
            else return false;
        }
    }
    return true;
}

int main()
{
    cin>>n;
    a.resize(n+1);
    vector<int> vec(n+1);
    vec[0]=-1;
    for(int i=1;i<=n;i++)
    {
        int x;
        cin>>x;
        a[i]=x;
        vec[i]=x;
    }
    sort(vec.begin(),vec.end());
    int l=1,r=n;
    while(l<r)
    {
        int mid=(l+r)/2;
        if(check(vec[mid]))
        {
            r=mid;
        }
        else l=mid+1;
    }
    cout<<vec[r];
}
```
由于只需要验证当前数是否和前一个数相同，或者当前数是否为第一次出现的数，所以这边直接使用一个变量来记录。有点类似于滚动的思想。