# P14918 [GESP202512 五级] 相等序列

## 题目描述

小 A 有一个包含 $N$ 个正整数的序列 $A=\{A_1,A_2,\ldots,A_N\}$。小 A 每次可以花费 $1$ 个金币执行以下任意一种操作：

- 选择序列中一个正整数 $A_i$（$1\le i\le N$），将 $A_i$ 变为 $A_i\times P$，$P$ 为任意质数；
- 选择序列中一个正整数 $A_i$（$1\le i\le N$），将 $A_i$ 变为 $\frac{A_i}{P}$，$P$ 为任意质数，要求 $A_i$ 是 $P$ 的倍数。

小 A 想请你帮他计算出令序列中所有整数都相同，最少需要花费多少金币。

## 输入格式

第一行一个正整数 $N$，含义如题面所示。

第二行包含 $N$ 个正整数 $A_1,A_2,\ldots,A_N$，代表序列 $A$。

## 输出格式

输出一行，代表最少需要花费的金币数量。

## 输入输出样例 #1

### 输入 #1

```
5
10 6 35 105 42
```

### 输出 #1

```
8
```

## 说明/提示

对于 $60\%$ 的测试点，保证 $1\le N,A_i\le 100$。

对于所有测试点，保证 $1\le N,A_i\le 10^5$。

## 题解&思考
这题非常有趣，但读完题，就能很容易想到标程。题目中明确点明
- 一个元素只能*或者/任意的质数。
- 最终需要最小步骤（开销）

顺着这个想法，我们尝试着将样例分解质因数。

### 输入 #1

```
5
10 6 35 105 42
```
分解的结果如下：
```
2 2 5 3 2
5 3 7 5 3
      7 7
```
我们发现，如果想让所有数都相同，那将没有一个质因数是多余的或者缺少的，于是我们再整理分解的结果：
```
2 2 _ _ 2
_ _ _ 3 3
5 _ 5 5 _
_ _ 7 7 7
```
如果按照从上到下质因数大小顺序排序，结果如上，然后对于有空缺的行，我们选择用最小的代价，将空缺填满还是将已有的数据删除

根据定理，任何数都可以分解为多个质因数的乘积。于是我们可以知道当我将所有质因数计数（一个数只记录一次），就可以得到当前行的质因数的次数。举个例子：
```
对于8、9这两个数
我们分解质因数并按格式记录：
2(3个) 2(0个) 
3(0个) 3(2个)
```
分解质因数问题不大，但关键是如何最优的进行选取。

我们知道，如果要将所有数都变为相同的数，那么他们的所有质因数也得相同。

```
这边拿数组中所有的数中2出现的次数来举例：
   a[1]  a[2] a[3] a[4] 
2:  1    100   10   5  (次)
```
那么这边的a[2]显然会进行降，而不是让其他的上升到100。

实际上到这里，能很快想到可以使用枚举进行判定，我们从0~max_cnt进行枚举，然后取最小代价即可完成。枚举的时间复杂度是 $log_2n$因为最小的质因数是2

代码的构建就非常的轻松了：
```
1. 遍历整个数组，并在遍历的时候将当前数质因数分解，将分解的质因数记录。

2. 遍历所有出现过的质因数，每个质因数中再遍历数组，找到对应最大质因数的出现次数max_pi_cnt。

3. 再次进行遍历质因数，每个质因数中再遍历数组。从0-max_pi_cnt进行枚举，当前枚举的终值计算公式是: abs(cnt_i-j)，其中j为当前枚举的值。 然后取最小终值即可。
```
这边时间复杂度为 $n*(2-n中质数个数)*logn$，n为1e5时，质数有约1e4个,所以会超时。喜提60，代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int main()
{
    int n;
    cin>>n;
    map<int,int> vec[N];
    set<int> S;
    vector<int> num(N);
    for(int i=0;i<n;i++)
    {
        int x;
        cin>>x;
        for(int j=2;j*j<=x;j++)
        {
            while(x%j==0)
            {
                vec[i][j]++;
                num[j]=max(num[j],vec[i][j]);
                x/=j;
                S.insert(j);
            }
        }
        if(x>=2)
        {
            vec[i][x]++;
            num[x]=max(num[x],vec[i][x]);
            S.insert(x);
        }
    }

    // 这边选择在处理质因数的时候开一个数组来更新最大出现的次数

    int ans=0;
    for(auto x: S) // 出现的质数
    {
        int mincnt=INT_MAX;
        for(int i=0;i<=num[x];i++)
        { // 枚举
            int tmp=0;
            for(int j=0;j<n;j++)
            { // 遍历数组
                tmp+=abs(vec[j][x]-i);
            }
            mincnt=min(mincnt,tmp);
        }
        ans+=mincnt;
    }
    cout<<ans;
}
```
再次思考，我们的逻辑是枚举得到一个最小的值，然后手动遍历所有元素中分解得到的质因数与该最小值之间的距离。那有没有一种办法可以不遍历数组直接得到距离呢？尝试寻找关系：
![alt text](image.png)
当我们枚举的时候，如果将当前数组排序（质因数个数数组）,那么当我当美剧到某一个数时，`<`当前数的我们执行批量加进行操作，`>`当前数的我们执行批量减操作。

判断哪一块该进行+哪一块该进行-，比较容易，只需要二分检查一下。但如何进行批量处理是个问题。

之前我们推出总公式为：$\sum abs(cnt-j)$ 

前半部分代价为 $\sum (j-cnt)=\sum j-\sum cnt$ ,其中j为当前枚举到的数。

后半部分为$\sum (cnt-j)=\sum cnt-\sum j$。

但别忘了，当前我们已经使用二分处理好了分界线，于是可以使用前缀和轻松拿到$\sum j$

然后再来算时间复杂度，由于我们需要从小到大排序，然后遍历数组，所以时间复杂度仍然在 $N*S$其中S为质数个数。时间复杂度不够的原因就在于质因数个数非常多。但是我们知道质因数数量在nlogn中。于是我们转变思想，不使用遍历质因数再遍历数组，而是仅遍历数组的方式来处理。

举个例子，当拆解8的时候，我们做一步pri[2].push_back(3);这实际上在处理一个稀疏矩阵。最终我们遍历所有的质因数，然后处理对应的数组，即处理pri[i]。将之排序然后通过二分处理该切割的位置。注意的是这边有很多0并没有push_back进入。所以最终计算时需要将总和+ $j*cnt_0$ 其中j为枚举的位置。

 **注意，这边的sort时间复杂度时nlogn，但由于每个质因数出现的次数不会很多，所以使用sort可以冲过去。**




所以得到的流程如下：
```
1. 处理每个数中的质因数

2. 遍历整个数组，将每个元素包含的质因数整理进全局的质数数量数组。

3. 排序后处理前缀和，这边不需要记录

4. 枚举，然后更新处理每个质因数最小值。
```

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int main()
{
    int n;
    cin>>n;
    map<int,int> vec[N];
    set<int> S;
    vector<int> num[N];
    for(int i=0;i<n;i++)
    {
        int x;
        cin>>x;
        for(int j=2;j*j<=x;j++)
        {
            while(x%j==0)
            {
                vec[i][j]++;
                x/=j;
                S.insert(j);
            }
        }
        if(x>=2)
        {
            vec[i][x]++;
            S.insert(x);
        }
    }
    for(int i=0;i<n;i++)
    {
        for(auto x:vec[i])
        {
            num[x.first].push_back(x.second);
        }
    }
    vector<int> pre_sum[N];
    for(auto x: S)
    {
        sort(num[x].begin(),num[x].end());
        pre_sum[x].resize(num[x].size()+1);
        pre_sum[x][0]=0;
        for(int i=1;i<=num[x].size();i++)
        {
            pre_sum[x][i]+=pre_sum[x][i-1]+num[x][i-1];
        }
    }
    int ans=0;
    for(auto x: S)
    {
        int t_sum=INT_MAX;
        for(int j=0;j<=num[x].back();j++)
        {
            int z=n-num[x].size();
            int idx=lower_bound(num[x].begin(),num[x].end(),j)-num[x].begin();
            int calc= j*idx - pre_sum[x][idx]+ (pre_sum[x][num[x].size()]-pre_sum[x][idx])-j*(num[x].size()-idx) +z*j;
            t_sum=min(t_sum,calc);
        }
        ans+=t_sum;
    }
    cout<<ans;
}
```
这边的计算过程有些复杂，实际上就是公式就是：

之前我们推出总公式为：$\sum abs(cnt-j)$ 

前半部分代价为 $\sum (j-cnt)=\sum j-\sum cnt$ ,其中j为当前枚举到的数。

后半部分为$\sum (cnt-j)=\sum cnt-\sum j$。

然后再加上缺失的部分，缺少的部分一定是不存在该质因数，那如何统计，实际上就是0，缺少几个，就有几个数不存在该质因数，所以为： z*j

okay，成功的做出来这题。
但实际上还可以进行优化，这边需要额外补充一个核心知识点。我们知道，最终的计算($\sum |x_i - k|$)的最小值，当K为 $x_i$中位数时一定成立。这边有很多推理过程，我觉得最让我接受的是纯数学的一个推理，这边贴上原回复：

![alt text](image-1.png)

所以这边可以不进行枚举，直接求取中位数。由于提前知道了目标值，所以直接遍历一遍数组使用 $\sum abs(cnt_i-medium)$ 即可。
代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;

// 建议使用 long long 防止累加过程中溢出（虽然本题数据范围 int 可能够，但习惯要好）
using ll = long long;

int main() {
    // 优化 I/O 速度
    ios::sync_with_stdio(false);
    cin.tie(0);

    int n;
    if (!(cin >> n)) return 0;

    // 核心数据结构：primes[p] 存储质数 p 在各个数字中出现的次数（非0部分）
    // 例如：primes[2] = {1, 1, 2, 5} 表示有4个数含有因子2，次数分别是1,1,2,5
    map<int, vector<int>> primes;

    for (int i = 0; i < n; i++) {
        int x;
        cin >> x;
        // 质因数分解
        for (int j = 2; j * j <= x; j++) {
            if (x % j == 0) {
                int cnt = 0;
                while (x % j == 0) {
                    cnt++;
                    x /= j;
                }
                primes[j].push_back(cnt);
            }
        }
        if (x > 1) {
            primes[x].push_back(1);
        }
    }

    ll ans = 0;

    // 遍历每一个出现过的质数
    for (auto& pair : primes) {
        vector<int>& exps = pair.second; // 取出该质数的指数列表
        sort(exps.begin(), exps.end());  // 排序，为了找中位数

        // 计算 0 的个数（即有多少个数字没有这个质因子）
        int zeros = n - exps.size();

        // 寻找中位数
        // 逻辑上的完整数组是： [0, 0, ..., 0, exps[0], exps[1], ...]
        // 总长度是 n，中位数下标是 n / 2
        int median = 0;
        int mid_idx = n / 2;

        if (mid_idx < zeros) {
            // 中位数落在 0 的区域
            median = 0;
        } else {
            // 中位数落在 exps 数组中
            // 它的下标需要减去前面 0 的个数
            median = exps[mid_idx - zeros];
        }

        // 计算代价
        // 1. 那些原本是 0 的数，变成 median 的代价
        // 代价 = zeros * |0 - median| = zeros * median
        ans += (ll)zeros * median;

        // 2. 那些原本非 0 的数，变成 median 的代价
        for (int e : exps) {
            ans += abs(e - median);
        }
    }

    cout << ans << endl;
    return 0;
}
```